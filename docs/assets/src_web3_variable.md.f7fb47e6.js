import{_ as s,c as a,o as l,V as n}from"./chunks/framework.2aaf49fa.js";const d=JSON.parse('{"title":"变量","description":"","frontmatter":{},"headers":[],"relativePath":"src/web3/variable.md","filePath":"src/web3/variable.md"}'),o={name:"src/web3/variable.md"},p=n(`<h1 id="变量" tabindex="-1">变量 <a class="header-anchor" href="#变量" aria-label="Permalink to &quot;变量&quot;">​</a></h1><p>solidity 变量有四种类型</p><ul><li>数值类型(Value Type)：包括布尔型，整数型等等，这类变量赋值时候直接传递数值。</li><li>引用类型(Reference Type)：包括数组和结构体，这类变量占空间大，赋值时候直接传递地址（类似指针）。</li><li>映射类型(Mapping Type): Solidity 里的哈希表。</li><li>函数类型(Function Type)：Solidity 文档里把函数归到数值类型，但我觉得他跟其他类型差别很大，所以单独分一类。</li></ul><h2 id="数值类型" tabindex="-1">数值类型 <a class="header-anchor" href="#数值类型" aria-label="Permalink to &quot;数值类型&quot;">​</a></h2><p>数值类型有整形，浮点型，布尔型，字符串，地址类型</p><h3 id="整型" tabindex="-1">整型 <a class="header-anchor" href="#整型" aria-label="Permalink to &quot;整型&quot;">​</a></h3><p>常用的整形有 <code>int</code> <code>uint</code> <code>uint256</code> ,其中 int 表示有符号整数, unint 表示无符号整数.</p><h3 id="布尔型" tabindex="-1">布尔型 <a class="header-anchor" href="#布尔型" aria-label="Permalink to &quot;布尔型&quot;">​</a></h3><p><code>&amp;&amp;</code> 和 <code>||</code> 运算符遵循短路规则，这意味着，假如存在 <code>f(x) || g(y)</code> 的表达式，如果 <code>f(x)</code> 是 <code>true</code> , <code>g(y)</code> 不会被计算</p><h3 id="地址类型" tabindex="-1">地址类型 <a class="header-anchor" href="#地址类型" aria-label="Permalink to &quot;地址类型&quot;">​</a></h3><p>有普通的地址和可以转账 ETH 的地址（加 <code>payable</code> 装饰变量）,普通 <code>adress</code> 修饰的地址有一个成员变量 <code>balance</code>，<code>payable</code> 修饰的地址相对普通地址多了 <code>transfer</code> 和 <code>send</code> 两个成员</p><div class="language-solidity"><button title="Copy Code" class="copy"></button><span class="lang">solidity</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">address</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">public</span><span style="color:#BABED8;"> _address </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">0x7A58c0Be72BE218B41C608b7Fe7C5bB630736C71</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#FFCB6B;">address</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">payable</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">public</span><span style="color:#BABED8;"> _address1 </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">payable</span><span style="color:#89DDFF;">(</span><span style="color:#BABED8;">_address</span><span style="color:#89DDFF;">);</span><span style="color:#BABED8;"> </span><span style="color:#676E95;font-style:italic;">// payable address，可以转账、查余额</span></span>
<span class="line"><span style="color:#FFCB6B;">uint256</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">public</span><span style="color:#BABED8;"> balance </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> _address1</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">balance</span><span style="color:#89DDFF;">;</span><span style="color:#BABED8;"> </span><span style="color:#676E95;font-style:italic;">// balance of address</span></span></code></pre></div><h3 id="字节数组" tabindex="-1">字节数组 <a class="header-anchor" href="#字节数组" aria-label="Permalink to &quot;字节数组&quot;">​</a></h3><p>数组 bytes 分两种，一种定长（byte, bytes8, bytes32），另一种不定长。定长的属于数值类型，不定长的是引用类型, 定长 bytes 可以存一些数据，消耗 gas 比较少。</p><div class="language-solidity"><button title="Copy Code" class="copy"></button><span class="lang">solidity</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">bytes32</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">public</span><span style="color:#BABED8;"> _byte32 </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#C3E88D;">&quot;MiniSolidity&quot;</span><span style="color:#89DDFF;">;</span><span style="color:#BABED8;"> </span><span style="color:#676E95;font-style:italic;">// 0x4d696e69536f6c6964697479000000000000000000000000000000000000000</span></span>
<span class="line"><span style="color:#FFCB6B;">bytes1</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">public</span><span style="color:#BABED8;"> _byte </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> _byte32</span><span style="color:#89DDFF;">[</span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">];</span><span style="color:#BABED8;"> </span><span style="color:#676E95;font-style:italic;">//_byte变量存储_byte32的第一个字节，为0x4d。</span></span></code></pre></div><h3 id="枚举" tabindex="-1">枚举 <a class="header-anchor" href="#枚举" aria-label="Permalink to &quot;枚举&quot;">​</a></h3><p>枚举（enum）是 solidity 中用户定义的数据类型。它主要用于为 uint 分配名称，使程序易于阅读和维护。</p><div class="language-solidity"><button title="Copy Code" class="copy"></button><span class="lang">solidity</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">enum</span><span style="color:#BABED8;"> </span><span style="color:#FFCB6B;">ActionSet</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span><span style="color:#BABED8;"> Buy</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> Hold</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> Sell </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 创建enum变量 action</span></span>
<span class="line"><span style="color:#BABED8;">ActionSet action </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> ActionSet</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">Buy</span><span style="color:#89DDFF;">;</span></span></code></pre></div><h2 id="函数类型" tabindex="-1">函数类型 <a class="header-anchor" href="#函数类型" aria-label="Permalink to &quot;函数类型&quot;">​</a></h2><div class="language-solidity"><button title="Copy Code" class="copy"></button><span class="lang">solidity</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">FUNCTION_NAME</span><span style="color:#89DDFF;">([</span><span style="color:#BABED8;font-style:italic;">可见性</span><span style="color:#89DDFF;">]</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">[</span><span style="color:#BABED8;font-style:italic;">参数</span><span style="color:#89DDFF;">],</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">...)</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">[</span><span style="color:#82AAFF;">可见性</span><span style="color:#89DDFF;">]</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">[</span><span style="color:#82AAFF;">读写性</span><span style="color:#89DDFF;">]</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">[</span><span style="color:#89DDFF;font-style:italic;">returns</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">(</span><span style="color:#BABED8;">&lt;</span><span style="color:#BABED8;font-style:italic;">return</span><span style="color:#BABED8;"> </span><span style="color:#BABED8;font-style:italic;">types</span><span style="color:#BABED8;">&gt;</span><span style="color:#89DDFF;">)]</span></span></code></pre></div><h3 id="可见性" tabindex="-1">可见性 <a class="header-anchor" href="#可见性" aria-label="Permalink to &quot;可见性&quot;">​</a></h3><p>可见性有以下几种</p><ul><li>public: 内部外部均可见。</li><li>private: 只能从本合约内部访问，继承的合约也不能用。</li><li>external: 只能从合约外部访问（但是可以用 this.f()来调用，f 是函数名）。</li><li>internal: 只能从合约内部访问，继承的合约可以用。</li></ul><p>方法默认为 <code>public</code> ,属性默认为 <code>internal</code></p><h3 id="读写性" tabindex="-1">读写性 <a class="header-anchor" href="#读写性" aria-label="Permalink to &quot;读写性&quot;">​</a></h3><p>读写性有三种 <code>pure</code> <code>view</code> <code>payable</code></p><p>由于读写数据是要消耗 gas 的，所以 EVM 对读写数据做了严格的区分。 <code>payable</code> 可读写合约中的数据, <code>pure</code> 不能读写合约中的数据，<code>view</code> 可以读但不能写</p><div class="language-solidity"><button title="Copy Code" class="copy"></button><span class="lang">solidity</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">contract</span><span style="color:#FFCB6B;"> PureAndView</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#FFCB6B;">uint</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">public</span><span style="color:#BABED8;"> number </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">5</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#676E95;font-style:italic;">// 下面的代码会报错，因为pure函数不能读写合约种的数据</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#676E95;font-style:italic;">//function pureAdd() pure returns uint(){</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#676E95;font-style:italic;">//    return number + 1;</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#676E95;font-style:italic;">//}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#676E95;font-style:italic;">// 下面的代码是可以通过的, 因为其并没有读写合约种的数据</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#C792EA;">function</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">pureAdd</span><span style="color:#89DDFF;">(</span><span style="color:#FFCB6B;">uint</span><span style="color:#BABED8;"> </span><span style="color:#BABED8;font-style:italic;">x</span><span style="color:#89DDFF;">)</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">public</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">pure</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;font-style:italic;">returns</span><span style="color:#89DDFF;">(</span><span style="color:#FFCB6B;">uint</span><span style="color:#89DDFF;">)</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#BABED8;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#BABED8;"> x </span><span style="color:#89DDFF;">+</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">1</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#676E95;font-style:italic;">// 与pure不同，view函数可以读取合约种的数据, 但不能写</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#C792EA;">function</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">viewAdd</span><span style="color:#89DDFF;">()</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">public</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">view</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;font-style:italic;">returns</span><span style="color:#89DDFF;">(</span><span style="color:#FFCB6B;">uint</span><span style="color:#89DDFF;">){</span></span>
<span class="line"><span style="color:#BABED8;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#BABED8;"> number </span><span style="color:#89DDFF;">+</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><h3 id="函数返回值" tabindex="-1">函数返回值 <a class="header-anchor" href="#函数返回值" aria-label="Permalink to &quot;函数返回值&quot;">​</a></h3><h4 id="returns-和-return" tabindex="-1">returns 和 return <a class="header-anchor" href="#returns-和-return" aria-label="Permalink to &quot;returns 和 return&quot;">​</a></h4><p>函数使用 returns 指定返回值类型, return 指定返回内容</p><div class="language-solidity"><button title="Copy Code" class="copy"></button><span class="lang">solidity</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">returnMultiple</span><span style="color:#89DDFF;">()</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">public</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">pure</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;font-style:italic;">returns</span><span style="color:#89DDFF;">(</span><span style="color:#FFCB6B;">uint256</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#FFCB6B;">bool</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#FFCB6B;">uint256</span><span style="color:#89DDFF;">[</span><span style="color:#BABED8;font-style:italic;">3</span><span style="color:#89DDFF;">]</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">memory</span><span style="color:#89DDFF;">){</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#FF9CAC;">true</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">[</span><span style="color:#FFCB6B;">uint256</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">),</span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">,</span><span style="color:#F78C6C;">5</span><span style="color:#89DDFF;">]);</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><h4 id="命名式返回" tabindex="-1">命名式返回 <a class="header-anchor" href="#命名式返回" aria-label="Permalink to &quot;命名式返回&quot;">​</a></h4><p>在 returns 中加上变量名后会自动返回变量</p><div class="language-solidity"><button title="Copy Code" class="copy"></button><span class="lang">solidity</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">returnNamed</span><span style="color:#89DDFF;">()</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">public</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">pure</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;font-style:italic;">returns</span><span style="color:#89DDFF;">(</span><span style="color:#FFCB6B;">uint256</span><span style="color:#BABED8;"> </span><span style="color:#BABED8;font-style:italic;">_number</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#FFCB6B;">bool</span><span style="color:#BABED8;"> </span><span style="color:#BABED8;font-style:italic;">_bool</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#FFCB6B;">uint256</span><span style="color:#89DDFF;">[</span><span style="color:#BABED8;font-style:italic;">3</span><span style="color:#89DDFF;">]</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">memory</span><span style="color:#BABED8;"> </span><span style="color:#BABED8;font-style:italic;">_array</span><span style="color:#89DDFF;">){</span></span>
<span class="line"><span style="color:#BABED8;">    _number </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#BABED8;">    _bool </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#FF9CAC;">false</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#BABED8;">    _array </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">[</span><span style="color:#FFCB6B;">uint256</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">3</span><span style="color:#89DDFF;">),</span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">,</span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">];</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><h4 id="解构式赋值" tabindex="-1">解构式赋值 <a class="header-anchor" href="#解构式赋值" aria-label="Permalink to &quot;解构式赋值&quot;">​</a></h4><div class="language-solidity"><button title="Copy Code" class="copy"></button><span class="lang">solidity</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">uint256</span><span style="color:#BABED8;"> _number</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#FFCB6B;">bool</span><span style="color:#BABED8;"> _bool</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#FFCB6B;">uint256</span><span style="color:#89DDFF;">[</span><span style="color:#F78C6C;">3</span><span style="color:#89DDFF;">]</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">memory</span><span style="color:#BABED8;"> _array</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">(</span><span style="color:#BABED8;">_number</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> _bool</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> _array</span><span style="color:#89DDFF;">)</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">returnNamed</span><span style="color:#89DDFF;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 不要的返回值可以留空</span></span>
<span class="line"><span style="color:#89DDFF;">(,</span><span style="color:#BABED8;"> _bool2</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">)</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">returnNamed</span><span style="color:#89DDFF;">();</span></span></code></pre></div><h2 id="引用类型" tabindex="-1">引用类型 <a class="header-anchor" href="#引用类型" aria-label="Permalink to &quot;引用类型&quot;">​</a></h2><p>引用类型(Reference Type)：包括数组（array），结构体（struct）和映射（mapping）,由于这类变量比较复杂，占用存储空间大，我们在使用时必须要声明数据存储的位置。</p><h3 id="数据位置" tabindex="-1">数据位置 <a class="header-anchor" href="#数据位置" aria-label="Permalink to &quot;数据位置&quot;">​</a></h3><p>solidity 数据存储位置有三类：<code>storage</code>，<code>memory</code> 和 <code>calldata</code>。不同存储位置的 gas 成本不同。storage 类型的数据存在链上，类似计算机的硬盘，消耗 gas 多；memory 和 calldata 类型的临时存在内存里，消耗 gas 少.</p><ul><li>storage：合约里的状态变量默认都是 storage，存储在链上。</li><li>memory：函数里的参数和临时变量一般用 memory，存储在内存中，不上链。</li><li>calldata：和 memory 类似，存储在内存中，不上链。与 memory 的不同点在于 calldata 变量不能修改（immutable），一般用于函数的参数。</li></ul><h3 id="数据位置和赋值规则" tabindex="-1">数据位置和赋值规则 <a class="header-anchor" href="#数据位置和赋值规则" aria-label="Permalink to &quot;数据位置和赋值规则&quot;">​</a></h3><p>引用类型的 storage 赋值给 storage 变量时会创建<strong>引用</strong>, 故修改新变量时会影响旧变量</p><p>引用类型的 storage 赋值给 memory 变量时会创建<strong>独立副本</strong>, 故修改新变量时不会影响旧变量</p><p>memory 赋值给 memory 时会创建<strong>引用</strong></p><p>其他情况，变量赋值给 storage 会创建独立的副本</p><h3 id="变量的作用域" tabindex="-1">变量的作用域 <a class="header-anchor" href="#变量的作用域" aria-label="Permalink to &quot;变量的作用域&quot;">​</a></h3><p>solidity 变量的作用域有三种</p><ol><li>状态变量: 声明在合约内方法外. 可在合约中访问. 其是 storage 类型的, 故修改时消耗的 gas 较大.</li><li>局部变量: 声明在方法内. 仅可在方法内访问. 当方法执行结束后即被销毁, 故消耗 gas 低.</li><li>全局变量: 由 solidity 事先定义, 可在任何地方访问. 以下是一些常见全局变量: <ul><li>blockhash(uint blockNumber): (bytes32)给定区块的哈希值 – 只适用于 256 最近区块, 不包含当前区块。</li><li>block.coinbase: (address payable) 当前区块矿工的地址</li><li>block.gaslimit: (uint) 当前区块的 gaslimit</li><li>block.number: (uint) 当前区块的 number</li><li>block.timestamp: (uint) 当前区块的时间戳，为 unix 纪元以来的秒</li><li>gasleft(): (uint256) 剩余 gas</li><li>msg.data: (bytes calldata) 完整 call data</li><li>msg.sender: (address payable) 消息发送者 (当前 caller)</li><li>msg.sig: (bytes4) calldata 的前四个字节 (function identifier)</li><li>msg.value: (uint) 当前交易发送的 wei 值</li></ul></li></ol><h2 id="引用类型-1" tabindex="-1">引用类型 <a class="header-anchor" href="#引用类型-1" aria-label="Permalink to &quot;引用类型&quot;">​</a></h2><h3 id="数组" tabindex="-1">数组 <a class="header-anchor" href="#数组" aria-label="Permalink to &quot;数组&quot;">​</a></h3><p>数组分为可变数组和不可变数组</p><p>不可变数组在声明时即声明其长度, 可变数组则不声明其长度</p><div class="language-solidity"><button title="Copy Code" class="copy"></button><span class="lang">solidity</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">uint</span><span style="color:#89DDFF;">[</span><span style="color:#F78C6C;">10</span><span style="color:#89DDFF;">]</span><span style="color:#BABED8;"> nums</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#BABED8;">unit</span><span style="color:#89DDFF;">[]</span><span style="color:#BABED8;"> nums2</span><span style="color:#89DDFF;">;</span></span></code></pre></div><blockquote><p>注意：bytes 比较特殊，是数组，但是不用加[]。另外，不能用 byte[]声明单字节数组，可以使用 bytes 或 bytes1[]。在 gas 上，bytes 比 bytes1[]便宜。因为 bytes1[]在 memory 中要增加 31 个字节进行填充，会产生额外的 gas。但是在 storage 中，由于内存紧密打包，不存在字节填充。</p></blockquote><h2 id="question" tabindex="-1">question <a class="header-anchor" href="#question" aria-label="Permalink to &quot;question&quot;">​</a></h2><ol><li>为什么 solidity 文档把函数类型归到数值类型</li><li>为什么映射类型单独归类而不是归类到引用类型</li><li>在数据位置和赋值规则中, 非引用类型也适用吗? 赋值不在方法内上述规则有效吗?</li></ol>`,58),e=[p];function t(c,r,i,y,D,F){return l(),a("div",null,e)}const u=s(o,[["render",t]]);export{d as __pageData,u as default};
